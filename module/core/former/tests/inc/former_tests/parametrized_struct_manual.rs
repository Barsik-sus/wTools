#![ allow( dead_code ) ]
#[ allow( unused_imports ) ]
use super::*;

#[ derive( Debug, PartialEq, Default ) ]
pub struct Property< Name >
{
  name : Name,
  code : isize,
}

/// generated by new
impl< Name > Property< Name >
{
  #[ inline ]
  pub fn new< Code >( name : Name, code : Code ) -> Self
  where
    Name : core::convert::Into< Name >,
    Code : core::convert::Into< isize >,
  {
    Self { name : name.into(), code : code.into() }
  }
}

// #[ derive( Debug, PartialEq, the_module::Former ) ]
// #[ derive( Debug, PartialEq, the_module::Former ) ] #[ debug ]
#[ derive( Debug, PartialEq ) ]
pub struct Command< K >
where
  K : core::hash::Hash + std::cmp::Eq,
{
  pub name : String,
  // #[ subformer( former::HashMapDefinition ) ]
  pub properties : collection_tools::HashMap< K, Property< K > >,
}

// == begin_coercing of generated

#[ automatically_derived ]
impl< K, > Command< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{



  #[ inline( always ) ]
  pub fn former() -> CommandFormer< K, CommandFormerDefinition< K, (), Command< K, >, former :: ReturnPreformed > >
  {
    CommandFormer :: < K, CommandFormerDefinition< K, (), Command< K, >, former :: ReturnPreformed > > :: new( former :: ReturnPreformed )
  }
}

#[ derive( Debug ) ]
pub struct CommandFormerDefinitionTypes< K, __Context = (), __Formed = Command< K, >, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  _phantom : core :: marker :: PhantomData< ( K, __Context, __Formed ) >,
}

impl< K, __Context, __Formed, > :: core :: default :: Default for CommandFormerDefinitionTypes< K, __Context, __Formed, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  fn default() -> Self
  {
    Self
    {
      _phantom : core :: marker :: PhantomData,
    }
  }
}

impl< K, __Context, __Formed, > former :: FormerDefinitionTypes for CommandFormerDefinitionTypes< K, __Context, __Formed, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  type Storage = CommandFormerStorage< K, >;
  type Formed = __Formed;
  type Context = __Context;
}

#[ derive( Debug ) ]
pub struct CommandFormerDefinition< K, __Context = (), __Formed = Command< K, >, __End = former :: ReturnPreformed, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  _phantom : core :: marker :: PhantomData< ( K, __Context, __Formed, __End ) >,
}

impl< K, __Context, __Formed, __End, > :: core :: default :: Default for CommandFormerDefinition< K, __Context, __Formed, __End, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  fn default() -> Self
  {
    Self
    {
      _phantom : core :: marker :: PhantomData,
    }
  }
}

impl< K, __Context, __Formed, __End, > former :: FormerDefinition for CommandFormerDefinition< K, __Context, __Formed, __End, > where __End : former :: FormingEnd< CommandFormerDefinitionTypes< K, __Context, __Formed, > >, K : core :: hash :: Hash + std :: cmp :: Eq,
{
  type Types = CommandFormerDefinitionTypes< K, __Context, __Formed, >;
  type End = __End;
}

pub type CommandFormerWithClosure< K, __Context, __Formed, > = CommandFormerDefinition< K, __Context, __Formed, former :: FormingEndClosure< CommandFormerDefinitionTypes< K, __Context, __Formed, > > >;


pub struct CommandFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{

  pub name : :: core :: option :: Option< String >,

  pub properties : :: core :: option :: Option< collection_tools :: HashMap< K, Property< K > > >,
}

impl< K, > :: core :: default :: Default for CommandFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  #[ inline( always ) ]
  fn default() -> Self
  {
    Self
    {
      name : :: core :: option :: Option :: None,
      properties : :: core :: option :: Option :: None,
    }
  }
}

impl< K, > former :: Storage for CommandFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  type Formed = Command< K, >;
}

impl< K, > former :: StoragePreform for CommandFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  type Preformed = Command< K, >;

  fn preform( mut self ) -> Self::Preformed
  // fn preform( mut self ) -> < Self as former :: Storage > :: Formed
  {
    let name = if self.name.is_some()
    {
      self.name.take().unwrap()
    }
    else
    {
      {
        trait MaybeDefault< T >
        {
          fn maybe_default( self : & Self ) -> T
          {
            panic!( "Field 'name' isn't initialized" )
          }
        }
        impl< T > MaybeDefault< T > for & :: core :: marker :: PhantomData< T > {}
        impl< T > MaybeDefault< T > for :: core :: marker :: PhantomData< T > where T : :: core :: default :: Default,
        {
          fn maybe_default( self : & Self ) -> T { T :: default() }
        }
        ( & :: core :: marker :: PhantomData :: < String > ).maybe_default()
      }
    };

    let properties = if self.properties.is_some()
    {
      self.properties.take().unwrap()
    }
    else
    {
      {
        trait MaybeDefault< T >
        {
          fn maybe_default( self : & Self ) -> T
          {
            panic!( "Field 'properties' isn't initialized" )
          }
        }
        impl< T > MaybeDefault< T > for & :: core :: marker :: PhantomData< T > {}
        impl< T > MaybeDefault< T > for :: core :: marker :: PhantomData< T > where T : :: core :: default :: Default,
        {
          fn maybe_default( self : & Self ) -> T { T :: default() }
        }
        ( & :: core :: marker :: PhantomData :: < collection_tools :: HashMap< K, Property< K > > > ).maybe_default()
      }
    };

    let result = Command :: < K, > { name, properties, };
    return result;
  }
}

pub struct CommandFormer< K, Definition = CommandFormerDefinition< K, (), Command< K, >, former::ReturnPreformed >, >
where
  K : core::hash::Hash + std::cmp::Eq,
  Definition : former::FormerDefinition,
  Definition::Types : former::FormerDefinitionTypes< Storage = CommandFormerStorage< K, > >
{
  storage : < Definition::Types as former::FormerDefinitionTypes >::Storage,
  context : core::option::Option< < Definition::Types as former::FormerDefinitionTypes >::Context >,
  on_end : core::option::Option< Definition::End >,
}

#[ automatically_derived ]
impl< K, Definition, > CommandFormer< K, Definition, >
where
  K : core::hash::Hash + std::cmp::Eq,
  Definition : former::FormerDefinition,
  Definition::Types : former::FormerDefinitionTypes< Storage = CommandFormerStorage< K, > >
{
  #[ inline( always ) ]
  pub fn perform( self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    let result = self.form();
    return result;
  }

  #[ inline( always ) ]
  pub fn _new_precise( on_end : Definition::End ) -> Self
  {
    Self::begin_coercing( None, None, on_end )
  }

  #[ inline( always ) ]
  pub fn new< IntoEnd >( end : IntoEnd ) -> Self
  where IntoEnd : Into< Definition::End >
  {
    Self::begin_coercing( None, None, end )
  }

  #[ inline( always ) ]
  pub fn _begin_precise( mut storage : core::option::Option< < Definition::Types as former::FormerDefinitionTypes >::Storage >, context : core::option::Option< < Definition::Types as former::FormerDefinitionTypes >::Context >, on_end : < Definition as former::FormerDefinition >::End, ) -> Self
  {
    if storage.is_none()
    {
      storage = Some( ::core::default::Default::default() );
    }
    Self
    {
      storage : storage.unwrap(),
      context : context,
      on_end : ::core::option::Option::Some( on_end ),
    }
  }

  #[ inline( always ) ]
  pub fn begin_coercing< IntoEnd >( mut storage : core::option::Option< < Definition::Types as former::FormerDefinitionTypes >::Storage >, context : core::option::Option< < Definition::Types as former::FormerDefinitionTypes >::Context >, on_end : IntoEnd, ) -> Self
  where IntoEnd : ::core::convert::Into< < Definition as former::FormerDefinition >::End >
  {
    if storage.is_none()
    {
      storage = Some( ::core::default::Default::default() );
    }
    Self
    {
      storage : storage.unwrap(),
      context : context,
      on_end : ::core::option::Option::Some( ::core::convert::Into::into( on_end ) ),
    }
  }

  #[ inline( always ) ]
  pub fn form( self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    self.end()
  }

  #[ inline( always ) ]
  pub fn end( mut self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    let on_end = self.on_end.take().unwrap();
    let context = self.context.take();
    former::FormingEnd::< Definition::Types >::call( &on_end, self.storage, context )
  }

  #[ inline ]
  pub fn name< Src >( mut self, src : Src ) -> Self
  where Src : ::core::convert::Into< String >
  {
    debug_assert!( self.storage.name.is_none() );
    self.storage.name = ::core::option::Option::Some( ::core::convert::Into::into( src ) );
    self
  }

  #[ inline( always ) ]
  pub fn properties_set< Former2 >( self ) -> Former2
  where Former2 : former::FormerBegin< former::HashMapDefinition< K, Property< K >, Self, Self, CommandFormerPropertiesEnd, > >
  {
    Former2::_begin( None, Some( self ), CommandFormerPropertiesEnd )
  }

  #[ inline( always ) ]
  pub fn properties( self ) -> former::ContainerSubformer::< ( K, Property< K >, ), former::HashMapDefinition< K, Property< K >, Self, Self, CommandFormerPropertiesEnd > >
  {
    self.properties_set::< former::ContainerSubformer::< ( K, Property< K >, ), former::HashMapDefinition< K, Property< K >, Self, Self, CommandFormerPropertiesEnd > >>()
  }
}

//

impl< K, Definition, > CommandFormer< K, Definition, >
where
  K : core::hash::Hash + std::cmp::Eq,
  Definition : former::FormerDefinition,
  Definition::Types : former::FormerDefinitionTypes< Storage = CommandFormerStorage< K, >, Formed = Command< K, > >,
  < Definition::Types as former::FormerDefinitionTypes >::Storage : former::StoragePreform,
  < Definition::Types as former::FormerDefinitionTypes >::Storage : former::StoragePreform< Preformed = Command< K, > >
{
  pub fn preform( self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    former::StoragePreform::preform( self.storage )
  }
}


#[ allow( non_camel_case_types ) ]
pub struct CommandFormerPropertiesEnd;

#[ automatically_derived ]
impl< K, Definition, > former::FormingEnd< former::HashMapDefinition< K, Property< K >, CommandFormer< K, Definition, >, CommandFormer< K, Definition, >, former::NoEnd >, > for CommandFormerPropertiesEnd
where
  K : core::hash::Hash + std::cmp::Eq,
  Definition : former::FormerDefinition,
  Definition::Types : former::FormerDefinitionTypes< Storage = CommandFormerStorage< K, > >
{
  #[ inline( always ) ]
  fn call( &self, storage : collection_tools::HashMap< K, Property< K > >, super_former : Option< CommandFormer< K, Definition, > >, ) -> CommandFormer< K, Definition, >
  {
    let mut super_former = super_former.unwrap();
    if let Some( ref mut field ) = super_former.storage.properties
    {
      former::ContainerAssign::assign( field, storage );
    }
    else
    {
      super_former.storage.properties = Some( storage );
    }
    super_former
  }
}

// == end of generated

include!( "./only_test/parametrized_struct.rs" );
