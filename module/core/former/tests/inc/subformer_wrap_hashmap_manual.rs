// xxx : finish
use super::*;

#[ derive( Debug, PartialEq ) ]
pub struct HashMapWrap< K, E >
where
  K : core::hash::Hash + std::cmp::Eq
{
  pub container : std::collections::HashMap< K, E >,
}

impl< K, E > Default for HashMapWrap< K, E >
where
  K : core::hash::Hash + std::cmp::Eq
{
  #[ inline( always ) ]
  fn default() -> Self
  {
    Self { container : Default::default() }
  }
}

pub trait End< T, Context >
{
  fn call( &self, container : T, context : Context ) -> Context;
}

impl< T, Context, F > End< T, Context > for F
where
  F : Fn( T, Context ) -> Context,
{
  #[ inline( always ) ]
  fn call( &self, container : T, context : Context ) -> Context
  {
    self( container, context )
  }
}

pub struct NoEnd;

impl< T, Context > End< T, Context >
for NoEnd
{
  #[ inline( always ) ]
  fn call( &self, _container : T, context : Context ) -> Context
  {
    context
  }
}

// pub fn noop< T, Context >
// (
//   _context : Context,
//   _container : core::option::Option< T >,
// )
// {
// }

// generated by new
impl< K, E > HashMapWrap< K, E >
where
  K : core::hash::Hash + std::cmp::Eq
{

  #[ inline( always ) ]
  pub fn new( container : std::collections::HashMap< K, E > ) -> Self
  {
    Self { container }
  }

}

// generated by former
impl< K, E > HashMapWrap< K, E >
where
  K : core::hash::Hash + std::cmp::Eq
{

  #[ inline( always ) ]
  pub fn former() -> HashMapWrapFormer< K, E, (), impl End< std::collections::HashMap< K, E >, () > >
  {
    HashMapWrapFormer::< K, E, (), NoEnd >::new
    (
      core::option::Option::None,
      (),
      NoEnd,
    )
  }

}

// generated by former
// #[ derive( Debug, Default ) ]
pub struct HashMapWrapFormer< K, E, Context = (), End = NoEnd >
where
  K : core::hash::Hash + std::cmp::Eq,
{
  container : core::option::Option< std::collections::HashMap< K, E > >,
  context : core::option::Option< Context >,
  on_end : core::option::Option< End >,
  _e_phantom : core::marker::PhantomData< E >,
  _k_phantom : core::marker::PhantomData< K >,
}

// generated by former
impl< K, E, Context, P >
HashMapWrapFormer< K, E, Context, P >
where
  K : core::cmp::Eq + core::hash::Hash,
  P : End< std::collections::HashMap< K, E >, Context >,
{

  #[ inline( always ) ]
  fn form( mut self ) -> std::collections::HashMap< K, E >
  {

    let container = if self.container.is_some()
    {
      self.container.take().unwrap()
    }
    else
    {
      let val = Default::default();
      val
    };

    container
  }

  /// Return former of your struct moving container there. Should be called after configuring the container.
  #[ inline( always ) ]
  pub fn end( mut self ) -> Context
  {
    let on_end = self.on_end.take().unwrap();
    let context = self.context.take().unwrap();
    let container = self.form();
    on_end.call( container, context )
  }

  #[ inline( always ) ]
  pub fn container< Src >( mut self, src : Src ) -> Self
  where Src : core::convert::Into< std::collections::HashMap< K, E > >
  {
    debug_assert!( self.container.is_none() );
    self.container = Some( src.into() );
    self
  }

  #[ inline( always ) ]
  pub fn new
  (
    container : core::option::Option< std::collections::HashMap< K, E > >,
    context : Context,
    on_end : P,
  ) -> Self
  {
    Self
    {
      container,
      context : Some( context ),
      on_end : Some( on_end ),
      _e_phantom : core::marker::PhantomData,
      _k_phantom : core::marker::PhantomData,
    }
  }

  /// Set the whole container instead of setting each element individually.
  #[ inline( always ) ]
  pub fn replace( mut self, src : std::collections::HashMap< K, E > ) -> Self
  {
    self.container = Some( src );
    self
  }

}

impl< K, E, Context, P >
HashMapWrapFormer< K, E, Context, P >
where
  K : core::cmp::Eq + core::hash::Hash,
  P : End< std::collections::HashMap< K, E >, Context >,
{

  /// Inserts a key-value pair into the map. Make a new container if it was not made so far.
  #[ inline( always ) ]
  pub fn insert< K2, E2 >( mut self, k : K2, e : E2 ) -> Self
  where
    K2 : core::convert::Into< K >,
    E2 : core::convert::Into< E >,
  {
    if self.container.is_none()
    {
      self.container = core::option::Option::Some( Default::default() );
    }
    if let core::option::Option::Some( ref mut container ) = self.container
    {
      container.insert( k.into(), e.into() );
    }
    self
  }

}

//

include!( "only_test/subformer_wrap_hashmap.rs" );
