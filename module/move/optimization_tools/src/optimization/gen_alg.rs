//! Implementation of genetic algorithm for sudoku solving.
//! 
//! Initial population is generated by randomly filling every block in sudoku board with unique numbers.
//! 
//! Fitness is calculated as number of errors in board.
//!
//! New population is generated partially from fittest individuals( percent is determined by elite_selection_rate GAConfig value ),
//! partially from randomly chosen individuals( percent is determined by random_selection_rate GAConfig value ) and rest is generated
//! as offspring of crossover of random pair of individuals, selected by tournament method.
//! 
//! Tournament is performed by randomly selecting a group of individuals from the population( the number of individuals selected is equal to the tournament_size value in GAConfig).
//! Likelihood of win of the fittest participant is determined by tournament_selection_pressure in GAConfig.
//! 
//! Crossover is performed by combining blocks from parents' boards, split in several randomly chosen crossover points.
//! 
//! New population is modified by appling mutation to some individuals in the population. Individual's likelihood of being mutated id determined by
//! mutation_rate GAConfig value.
//! 
//! Termination: process is stopped if sudoku solution is found or if max_generation_number value is exseeded.
//! 

use std::collections::HashSet;

use deterministic_rand::{ Hrng, Seed };
use iter_tools::Itertools;
use rand::{ seq::SliceRandom, Rng };

use crate::{ sudoku::*, optimization::* };

/// Configuration of GA implementation.
#[ derive( Clone, Debug ) ]
pub struct GAConfig
{
  /// Size of population.
  pub population_size : usize,
  /// Number of fittest individuals that will be selected as possible breeders of new population.
  pub elite_selection_rate : f64,
  /// Number of random individuals that will be selected as possible breeders of new population.
  pub random_selection_rate : f64,
  /// Probabilistic measure of a individual mutation likelihood.
  pub mutation_rate : f64,
  /// Number of individuals that will compete against each other in each round of the tournament.
  pub tournament_size : usize,
  /// Probabilistic measure of a individuals likelihood of being selected in the tournament.
  pub tournament_selection_pressure : f64,
  /// Recalculate fitnell on every iteration.
  pub fitness_recalculation : bool,
  /// Max number of iteration without improvement in population.
  pub max_stale_iterations: usize,
  /// Max total number of iterations.
  pub max_generation_number : usize,
}

impl Default for GAConfig
{
  fn default() -> Self 
  {
    Self
    {
      population_size : 50000,
      elite_selection_rate : 0.15,
      random_selection_rate : 0.25,
      max_stale_iterations: 30,
      tournament_size : 2,
      tournament_selection_pressure : 0.85,
      fitness_recalculation : false,
      max_generation_number : 1000,
      mutation_rate : 0.5,
    }
  }
}

pub trait CrossoverOperator
{
  fn crossover( &self, hrng : Hrng, parent1 : &SudokuPerson, parent2 : SudokuPerson ) -> SudokuPerson;
}

pub struct MultiplePointsBlockCrossover {}

impl CrossoverOperator for MultiplePointsBlockCrossover
{
  fn crossover( &self, hrng : Hrng, parent1 : &SudokuPerson, parent2 : SudokuPerson ) -> SudokuPerson 
  {
    let rng_ref = hrng.rng_ref();
    let mut rng = rng_ref.lock().unwrap();

    let possible_values = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
    let first_parent_blocks_number = possible_values.choose( &mut *rng ).unwrap();
    let mut first_parent_blocks : HashSet< BlockIndex > = HashSet::new();

    while first_parent_blocks.len() != *first_parent_blocks_number
    {
      first_parent_blocks.insert( rng.gen() );
    }

    let mut child_storage: Vec< CellVal > = vec![ 0.into(); 81 ];

    for i in parent1.board.blocks()
    {
      if first_parent_blocks.contains( &i )
      {
        let parent_block = parent1.board.block( i ).collect_vec();
        let cells = parent1.board.block_cells( i );
        for ( index, cell_index ) in cells.enumerate()
        {
          child_storage[ usize::from( cell_index ) ] = parent_block[ index ];
        }
      }
      else 
      {
        let parent_block = parent2.board.block( i ).collect_vec();
        let cells = parent2.board.block_cells( i );
        for ( index, cell_index ) in cells.enumerate()
        {
          child_storage[ usize::from( cell_index ) ] = parent_block[ index ];
        }
      }
    }

    let child = SudokuPerson::with_board( Board::new( child_storage ) );
    child
  }
}

/// Represents initial state of board and configuration of GA optimization process for sudoku solving.
#[ derive( Clone, Debug ) ]
pub struct GASudokuInitial
{
  /// Initial state of sudoku board with fixed values.
  pub board : Board,
  /// Seed for random numbers generator.
  pub seed : Seed,
  /// Random numbers generator used for creating new populations of GA.
  pub hrng : Hrng,
  pub config : GAConfig,
}

impl GASudokuInitial
{
  /// Create new initial state for GA.
  pub fn new( board : Board, seed : Seed ) -> Self
  {
    let hrng = Hrng::master_with_seed( seed.clone() );
    Self
    {
      seed,
      hrng,
      board,
      config : GAConfig::default()
    }
  }

  pub fn set_population_size( mut self, size : usize ) -> Self
  {
    self.config.population_size = size;
    self
  }

  pub fn set_mutation_rate( mut self, rate : f64 ) -> Self
  {
    self.config.mutation_rate = rate;
    self
  }

  pub fn set_elite_selection_rate( mut self, rate : f64 ) -> Self
  {
    self.config.elite_selection_rate = rate;
    self
  }

  pub fn set_random_selection_rate( mut self, rate : f64 ) -> Self
  {
    self.config.random_selection_rate = rate;
    self
  }

  /// Seed initial population of solutions.
  pub fn initial_population( &self ) -> Vec< SudokuPerson >
  {
    let mut population = Vec::with_capacity( self.config.population_size );
    for _ in 0..self.config.population_size
    {
      let person = SudokuPerson::new( &self.board, self.hrng.clone() );
      population.push( person );
    }
    population
  }

  /// Implementention of tournament selection method:
  /// Several individuals are randomly chosen from population, they take part in competition where the fittest are the most likely to win.
  pub fn tournament< 'a >( &self, population : &'a Vec< SudokuPerson > ) -> &'a SudokuPerson
  {
    let rng_ref = self.hrng.rng_ref();
    let mut rng = rng_ref.lock().unwrap();
    let mut candidates = Vec::new();
    for _ in 0..self.config.tournament_size
    {
      candidates.push( population.choose( &mut *rng ).unwrap() );
    }
    candidates.sort_by( | c1, c2 | c1.fitness().cmp( &c2.fitness() ) );

    let rand : f64 = rng.gen();
    let mut selection_pressure = self.config.tournament_selection_pressure;
    let mut winner = *candidates.last().unwrap();
    for i in 0..self.config.tournament_size
    {
      if rand < selection_pressure
      {
        winner = candidates[ i ];
        break;
      }
      selection_pressure += selection_pressure * ( 1.0 - selection_pressure );
    }
    winner
  }

  /// Crossover genetic operator, combines genetic material from two parent individuals to produce offspring.
  /// Performs recombination at multiple randomly chosen crossover points.
  pub fn crossover( &self, parent1 : &SudokuPerson, parent2 : &SudokuPerson ) -> SudokuPerson
  {
    let rng_ref = self.hrng.rng_ref();
    let mut rng = rng_ref.lock().unwrap();

    let possible_values = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
    let first_parent_blocks_number = possible_values.choose( &mut *rng ).unwrap();
    let mut first_parent_blocks : HashSet< BlockIndex > = HashSet::new();

    while first_parent_blocks.len() != *first_parent_blocks_number
    {
      first_parent_blocks.insert( rng.gen() );
    }

    let mut child_storage: Vec< CellVal > = vec![ 0.into(); 81 ];

    for i in parent1.board.blocks()
    {
      if first_parent_blocks.contains( &i )
      {
        let parent_block = parent1.board.block( i ).collect_vec();
        let cells = parent1.board.block_cells( i );
        for ( index, cell_index ) in cells.enumerate()
        {
          child_storage[ usize::from( cell_index ) ] = parent_block[ index ];
        }
      }
      else 
      {
        let parent_block = parent2.board.block( i ).collect_vec();
        let cells = parent2.board.block_cells( i );
        for ( index, cell_index ) in cells.enumerate()
        {
          child_storage[ usize::from( cell_index ) ] = parent_block[ index ];
        }
      }
    }

    let child = SudokuPerson::with_board( Board::new( child_storage ) );
    child
  }

  /// Mutate population based on config mutation_rate parameter, if randomly picked number is less than mutation_rate, mutation is performed on individual. 
  pub fn mutate_population( &self, population : &mut Vec< SudokuPerson > )
  { 
    for person in population
    {
      let rng_ref = self.hrng.rng_ref();
      let mut rng = rng_ref.lock().unwrap();
      let rand : f64 = rng.gen();
      drop( rng );
      if rand < self.config.mutation_rate
      {
        person.mutate_random( &self.board, self.hrng.clone() );
      }
    }
  }

  pub fn evolve( &self, person: &SudokuPerson, population : &Vec< SudokuPerson > ) -> SudokuPerson
  {
    if population.iter().position( | p | p == person ).unwrap() <= ( population.len() as f64 * self.config.elite_selection_rate ) as usize
    {
      return person.clone();
    }

    let rng_ref = self.hrng.rng_ref();
    let mut rng = rng_ref.lock().unwrap();

    let rand : f64 = rng.gen();
    if rand < self.config.random_selection_rate
    {
      return person.clone();
    }

    let parent1 = self.tournament( &population );
    let parent2 = self.tournament( &population );
    let children = self.crossover_rows_columns( parent1, parent2 );

    let rand : f64 = rng.gen();
    drop( rng );
    if rand < self.config.mutation_rate
    {
      children.0.mutate_random( &self.board, self.hrng.clone() )
    }
    else 
    {
        children.0
    }
  }

  ///
  pub fn crossover_rows_columns( &self, parent1 : &SudokuPerson, parent2 : &SudokuPerson ) -> ( SudokuPerson, SudokuPerson )
  {
    let mut rows_costs = vec![ Vec::new(); 2 ];
    let mut columns_costs = vec![ Vec::new(); 2 ];
    for ( index, parent ) in [ parent1, parent2 ].iter().enumerate()
    {
      rows_costs[ index ] = parent.board
      .rows()
      .map( | row | row.collect::< HashSet< _ > >().len() )
      .collect_vec()
      .chunks( 3 )
      .map( | costs | 27 - costs.iter().fold( 0, | acc, cost | acc + cost ) )
      .collect_vec()
      ;

      columns_costs[ index ] = parent.board
      .cols()
      .map( | row | row.collect::< HashSet< _ > >().len() )
      .collect_vec()
      .chunks( 3 )
      .map( | costs | 27 - costs.iter().fold( 0, | acc, cost | acc + cost ) )
      .collect_vec()
      ;
    }

    let mut child1_storage = vec![ CellVal::from( 0 ); 81 ];
    for i in 0..3
    {
      if rows_costs[ 0 ][ i ] < rows_costs[ 1 ][ i ]
      {
        for j in 0..3
        {
          let parent_block = parent1.board.block( BlockIndex::from( ( j as u8, i as u8 ) ) ).collect_vec();
          let cells = parent1.board.block_cells( BlockIndex::from( ( j as u8, i as u8 ) ) );
          for ( index, cell_index ) in cells.enumerate()
          {
            child1_storage[ usize::from( cell_index ) ] = parent_block[ index ];
          }
        }
      }
      else
      {
        for j in 0..3
        {
          let parent_block = parent2.board.block( BlockIndex::from( ( j as u8, i as u8 ) ) ).collect_vec();
          let cells = parent2.board.block_cells( BlockIndex::from( ( j as u8, i as u8 ) ) );
          for ( index, cell_index ) in cells.enumerate()
          {
            child1_storage[ usize::from( cell_index ) ] = parent_block[ index ];
          }
        }
      }
    }

    //let mut child2_blocks = Vec::new();
    let mut child2_storage = vec![ CellVal::from( 0 ); 81 ];
    for i in 0..3
    {
      for j in 0..3
      {
        if columns_costs[ 0 ][ j ] < columns_costs[ 1 ][ j ]
        {
          let parent_block = parent1.board.block( BlockIndex::from( ( j as u8, i as u8 ) ) ).collect_vec();
          let cells = parent1.board.block_cells( BlockIndex::from( ( j as u8, i as u8 ) ) );
          for ( index, cell_index ) in cells.enumerate()
          {
            child2_storage[ usize::from( cell_index ) ] = parent_block[ index ];
          }
        }
        else 
        {
          let parent_block = parent2.board.block( BlockIndex::from( ( j as u8, i as u8 ) ) ).collect_vec();
          let cells = parent2.board.block_cells( BlockIndex::from( ( j as u8, i as u8 ) ) );
          for ( index, cell_index ) in cells.enumerate()
          {
            child2_storage[ usize::from( cell_index ) ] = parent_block[ index ];
          }
        }
      }
    }

    ( SudokuPerson::with_board( Board::new( child1_storage ) ), SudokuPerson::with_board( Board::new( child2_storage ) ) )
    
  }

  /// Applies genetic algorithm to solve sudoku.
  pub fn solve_with_ga( &self ) -> ( Reason, Option< SudokuPerson > )
  {
    let mut population = self.initial_population();
    let mut generation_number = 1;
    let mut stale = 0;
    let mut reseeds_number = 0;

    loop
    {
      if generation_number > self.config.max_generation_number
      {
        return ( Reason::GenerationLimit, None );
      }

      population.sort_by( | p1, p2 | p1.fitness().cmp( &p2.fitness() ) );
      log::trace!
      (
        "population's best score : {}",
        population[ 0 ].fitness(),
      );
      
      if population[ 0 ].fitness() == 0
      {
        log::trace!
        (
          "finished after {} generations, {} resets",
          generation_number, reseeds_number
        );
        println!( "{:?}", generation_number);
        return ( Reason::GoodEnough, Some( population[ 0 ].clone() ) );
      }

      if population[ 0 ].fitness() == population[ 1 ].fitness()
      {
        stale += 1;
      }
      else
      {
        stale = 0;
      }

      if stale >= self.config.max_stale_iterations
      {
        log::trace!( "population evolution staled, reseeding" );
        population = self.initial_population();
        reseeds_number += 1;
        stale = 0;
      }

      let mut new_population = Vec::new();
      for person in &population
      {
        new_population.push( self.evolve( &person, &population ) );
      }

      population = new_population;

      if self.config.fitness_recalculation
      {
        for person in &mut population
        {
          person.update_fitness()
        }
      }

      generation_number += 1;
    }
  }
}

pub trait IndividualFitness
{
  fn fitness( &self ) -> usize;
  fn update_fitness( &mut self );
}

impl IndividualFitness for SudokuPerson
{
  fn fitness( &self ) -> usize 
  {
    self.cost.into()
  }

  fn update_fitness( &mut self )
  {
    self.cost = self.board.total_error().into();
  }
}