//! Implementation of genetic algorithm for sudoku solving.
//! 
//! Initial population is generated by randomly filling every block in sudoku board with unique numbers.
//! 
//! Fitness is calculated as number of errors in board.
//!
//! New population is generated partially from fittest individuals( percent is determined by elite_selection_rate ),
//! partially from randomly chosen individuals( percent is determined by random_selection_rate ) and rest is generated
//! as offspring of crossover of random pair of individuals, selected by tournament method.
//! 
//! Tournament is performed by randomly selecting a group of individuals from the population( the number of individuals selected is equal to the tournament_size value).
//! Likelihood of win of the fittest participant is determined by tournament_selection_pressure.
//! 
//! Crossover is performed by combining blocks from parents' boards, split in several randomly chosen crossover points.
//! 
//! New population is modified by appling mutation to some individuals in the population. Individual's likelihood of being mutated id determined by mutation_rate value.
//! 
//! Termination: process is stopped if sudoku solution is found or if max_generation_number value is exseeded.
//! 

use std::fmt::Debug;
use deterministic_rand::Hrng;

use crate::optimization::*;

/// Functionality of crossover genetic operator.
pub trait CrossoverOperator : Debug
{
  type Person : Individual + Clone;
  /// Produce new Individual using genetic matherial of two selected Individuals.
  fn crossover( &self, hrng : Hrng, parent1 : &Self::Person, parent2 : &Self::Person ) -> Self::Person;
}

/// Performs selection of Individuals for genetic crossover and production of new Individual for next generation.
pub trait SelectionOperator< P : Individual > : Debug
{
  /// Select Individuals which will be used by GA crossover and mutation operators for production of new individual.
  fn select< 'a >( &self, hrng : Hrng, population : &'a Vec< P > ) -> &'a P;
}

/// Selection operator which randomly selects a group of individuals from the population( the number of individuals selected is equal to the size value) and choosing the most fit with probability defined by selection_pressure value.
#[ derive( Debug ) ]
pub struct TournamentSelection 
{
  /// Number of Individuals selected to compete in tournament.
  pub size : usize,
  /// Probabilistic measure of a individuals likelihood of being selected in the tournament.
  pub selection_pressure : f64,
}

/// Functionality of Individual(potential solution) for optimization with SA and GA.
pub trait Individual
{
  /// Objective function value that is used to measure how close Individual solution is to optimum.
  fn fitness( &self ) -> usize;
  /// Recalculate fitness value of individual.
  fn update_fitness( &mut self, value : f64 );
  /// Check if current solution is optimal.
  fn is_optimal( &self ) -> bool;
}
    
pub trait MutationOperator : Debug
{
  type Person : Individual;
  type Context;

  fn mutate( &self, hrng : Hrng, person : &mut Self::Person, context : &Self::Context );
}

/// Fuctionality of operator responsible for creation of initial solutions generation.
pub trait SeederOperator
{
  /// Type that represents generation of solutions in optimization process.
  type Person : Individual + Clone + PartialEq + Send + Sync;
  type Context : Sync;

  /// Create the initial generation for the optimization algorithm.
  fn initial_generation( &self, hrng : Hrng, size : usize ) -> Vec< Self::Person >;

  /// Create the initial generation for the optimization algorithm.
  fn initial_temperature( &self, hrng : Hrng ) -> Temperature;

  fn evaluate( &self, person : &Self::Person ) -> f64;

  fn context( &self ) -> &Self::Context;
}

/// Functionality of generation of solutions for optimization.
pub trait Generation
{
  /// Check if current generation contains optimal solution.
  fn is_good_enough( &self ) -> bool;
}

