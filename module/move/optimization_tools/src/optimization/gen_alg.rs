//! Implementation of genetic algorithm for sudoku solving.
//! 
//! Initial population is generated by randomly filling every block in sudoku board with unique numbers.
//! 
//! Fitness is calculated as number of errors in board.
//!
//! New population is generated partially from fittest individuals( percent is determined by elite_selection_rate ),
//! partially from randomly chosen individuals( percent is determined by random_selection_rate ) and rest is generated
//! as offspring of crossover of random pair of individuals, selected by tournament method.
//! 
//! Tournament is performed by randomly selecting a group of individuals from the population( the number of individuals selected is equal to the tournament_size value).
//! Likelihood of win of the fittest participant is determined by tournament_selection_pressure.
//! 
//! Crossover is performed by combining blocks from parents' boards, split in several randomly chosen crossover points.
//! 
//! New population is modified by appling mutation to some individuals in the population. Individual's likelihood of being mutated id determined by mutation_rate value.
//! 
//! Termination: process is stopped if sudoku solution is found or if max_dynasties_number value is exseeded.
//! 

use std::fmt::Debug;
use deterministic_rand::Hrng;

/// Functionality of crossover genetic operator.
pub trait CrossoverOperator : Debug
{
  /// Type that represents solution that crossover is performed on.
  type Person : Individual + Clone;

  /// Produce new Individual using genetic matherial of two selected Individuals.
  fn crossover( &self, hrng : Hrng, parent1 : &Self::Person, parent2 : &Self::Person ) -> Self::Person;
}

/// Performs selection of Individuals for genetic crossover and production of new Individual for next generation.
pub trait SelectionOperator< P : Individual > : Debug
{
  /// Select Individuals which will be used by GA crossover and mutation operators for production of new individual.
  fn select< 'a >( &self, hrng : Hrng, population : &'a Vec< P > ) -> &'a P;
}

/// Selection operator which randomly selects a group of individuals from the population( the number of individuals selected is equal to the size value) and choosing the most fit with probability defined by selection_pressure value.
#[ derive( Debug ) ]
pub struct TournamentSelection 
{
  /// Number of Individuals selected to compete in tournament.
  pub size : usize,
  /// Probabilistic measure of a individuals likelihood of being selected in the tournament.
  pub selection_pressure : f64,
}

/// Functionality of Individual(potential solution) for optimization with SA and GA.
pub trait Individual
{
  /// Objective function value that is used to measure how close Individual solution is to optimum.
  fn fitness( &self ) -> usize;
  /// Recalculate fitness value of individual.
  fn update_fitness( &mut self, value : f64 );
  /// Check if current solution is optimal.
  fn is_optimal( &self ) -> bool;
}

/// Mutation operator, used to randomly change person's genome and intoduce more diversity into population.
pub trait MutationOperator : Debug
{
  /// Type that represents possible solution of initial problem.
  type Person : Individual;
  /// Additional Information for mutation.
  type Problem : InitialProblem;

  /// Randomly changes person's genome.
  fn mutate( &self, hrng : Hrng, person : &mut Self::Person, context : &Self::Problem );
}

/// Fuctionality of operator responsible for creation of initial solutions population.
pub trait InitialProblem
{
  /// Type that represents Individual in population of solutions in optimization process.
  type Person : Individual + Clone + PartialEq + Send + Sync + Debug;

  /// Create the initial population for the optimization algorithm.
  fn initial_population( &self, hrng : Hrng, size : usize ) -> Vec< Self::Person >;

  /// Get random initial solution.
  fn get_random_person( &self, hrng : Hrng ) -> Self::Person;

  /// Evaluate fitness of provided solution.
  fn evaluate( &self, person : &Self::Person ) -> f64;
}

